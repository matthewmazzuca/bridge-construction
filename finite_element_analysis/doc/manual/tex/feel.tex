\feelchapter{Feel++ Language Keywords}
            {Feel++ Language Keywords}
            {Christophe Prud'homme}
            {cha:appendix-feel}

\section{Keywords}
\label{sec:keywords}

One of \feel assets is it finite element embedded language. The language follows the C++ grammar, and provides keywords
as well as operations between objects which are, mathematically, tensors of rank 0, 1 or 2. \\

\noindent Here are some notations :
\begin{itemize}
\item $f: \mathbb{R}^n \mapsto \mathbb{R}^{m\times p}$  with $n=1,2,3$, $m=1,2,3$, $p=1,2,3$.
\item $\Omega^e$ current mesh element
\end{itemize}
and here is the table which gathers all tools you may need:

\begin{longtable}[c]{rllll}
  Keyword & Math object & Description & Rank & $M \times N$\\\hline\hline

  \endhead
  %%
  %% Point
  %%
  \lstinline!P()! & $\overrightarrow{P}$ & current point coordinates $(P_x, P_y, P_z)^T$ & 1 & $d \times 1$ \\

  \lstinline!Px()! & $P_x$ & $x$ coordinate of $\overrightarrow{P}$ & 0 & $1 \times 1$\\

  \lstinline!Py()! & $P_y$ & $y$ coordinate of $\overrightarrow{P}$ & 0 & $1 \times 1$\\
  & &  (value is 0 in 1D) & &\\

  \lstinline!Pz()! & $P_z$ & $z$ coordinate of $\overrightarrow{P}$& 0 & $1 \times 1$\\
  & &  (value is 0 in 1D and 2D)  & &\\\hline\\

  %%
  %% Barycenter
  %%
  \lstinline!C()! & $\overrightarrow{C}$ & element barycenter point coordinates  & 1 & $d \times 1$ \\
  &&$(C_x, C_y, C_z)^T$&&\\

  \lstinline!Cx()! & $C_x$ & $x$ coordinate of $\overrightarrow{C}$ & 0 & $1 \times 1$\\

  \lstinline!Cy()! & $C_y$ & $y$ coordinate of $\overrightarrow{C}$ & 0 & $1 \times 1$\\
  & &  (value is 0 in 1D) & &\\

  \lstinline!Cz()! & $C_z$ & $z$ coordinate of $\overrightarrow{C}$& 0 & $1 \times 1$\\
  & &  (value is 0 in 1D and 2D)  & &\\\hline\\

  %%
  %% normal
  %%

  \lstinline!N()! & $\overrightarrow{N}$ & normal at current point $(N_x,N_y,N_z)^T$ & 1 & $d \times 1$\\

  \lstinline!Nx()! & $N_x$ & $x$ coordinate of $\overrightarrow{N}$ at current point & 0 & $1 \times 1$\\

  \lstinline!Ny()! & $N_y$ & $y$ coordinate of $\overrightarrow{N}$ at current point & 0 & $1 \times 1$\\
  & &  (value is 0 in 1D) & &\\

  \lstinline!Nz()! & $N_z$ & $z$ coordinate of $\overrightarrow{N}$ at current point& 0 & $1 \times 1$\\
  & &  (value is 0 in 1D and 2D)  & &\\\hline\\

  %%
  %% Element id
  %%
  \lstinline!eid()! & $e$ & index of  $\Omega^e$ & 0 & $1 \times 1$\\
  \lstinline!emarker()! & $m(e)$ & marker of  $\Omega^e$ & 0 & $1 \times 1$\\
  \lstinline!h()! & $h^e$ & size of   $\Omega^e$ & 0 & $1 \times 1$\\
  \lstinline!hFace()! & $h^e_{\Gamma}$ & size of face $\Gamma$ of $\Omega^e$ & 0 & $1 \times 1$\\\hline\\

  %%
  %% Mat/vec
  %%
  \lstinline!mat<M,N>(m_11,! &
  $\begin{pmatrix}
    m_{11} & m_{12} & ...\\
    m_{21} & m_{22} & ...\\
    \vdots & &
  \end{pmatrix}$
  & $M\times N$ matrix    & 2 & $M \times N$\\
  \lstinline!m_12,...)!& & entries being expressions   & &\\

  \lstinline!vec<M>(v_1,! &$(v_1, v_2,...)^T$
  & column vector with $M$ rows    & 1 & $M \times 1$\\
  \lstinline!v_2,...)!& & entries being expressions   & &\\

  \lstinline!trace(expr)! &$\mathrm{tr}(f(\overrightarrow{x}))$  & trace of $f(\overrightarrow{x})$   & 0 & $1 \times 1$\\\hline\\


  %%
  %% std math functions
  %%

  \lstinline!abs(expr)! & $|f(\overrightarrow{x})|$ & element wise absolute value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!cos(expr)! & $\cos(f(\overrightarrow{x}))$ & element wise cosinus value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!sin(expr)! & $\sin(f(\overrightarrow{x}))$ & element wise sinus value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!tan(expr)! & $\tan(f(\overrightarrow{x}))$ & element wise tangent value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!acos(expr)! & $\acos(f(\overrightarrow{x}))$ & element wise acos value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!asin(expr)! & $\asin(f(\overrightarrow{x}))$ & element wise asin value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!atan(expr)! & $\atan(f(\overrightarrow{x}))$ & element wise atan value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!cosh(expr)! & $\cosh(f(\overrightarrow{x}))$ & element wise cosh value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!sinh(expr)! & $\sinh(f(\overrightarrow{x}))$ & element wise sinh value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!tanh(expr)! & $\tanh(f(\overrightarrow{x}))$ & element wise tanh value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!exp(expr)! & $\exp(f(\overrightarrow{x}))$ & element wise exp value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!log(expr)! & $\log(f(\overrightarrow{x}))$ & element wise log value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!sqrt(expr)! & $\sqrt{f(\overrightarrow{x})}$ & element wise sqrt value of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!sign(expr)! & $
  \begin{cases}
    1 & \text{if}\ f(\overrightarrow{x}) \geq 0\\
    -1 & \text{if}\ f(\overrightarrow{x}) < 0
  \end{cases}$ & element wise sign of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!chi(expr)! & $\chi(f(\overrightarrow{x}))=$ & element wise boolean test of $f$ & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  & $\begin{cases}
    0 & \text{if}\ f(\overrightarrow{x}) = 0\\
    1 & \text{if}\ f(\overrightarrow{x}) \neq 0\\
  \end{cases}$ &&&\\\hline\\

  %%
  %% operation
  %%
  \lstinline!id(f)! & $f$ & test function & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!idt(f)! & $f$ & trial function & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!idv(f)! & $f$ & evaluation function   & $\mathrm{rank}(f(\overrightarrow{x}))$ & $m \times p$\\
  \lstinline!grad(f)! & $\nabla f$ & gradient of test function & $\mathrm{rank}( f(\overrightarrow{x}))+1$ & $p=1,\ m \times n$\footnote{Gradient of matrix value functions is not implemented, hence $p=1$ }\\
  \lstinline!gradt(f)! & $\nabla f$ & gradient of trial function & $\mathrm{rank}(f(\overrightarrow{x}))+1$ & $p=1,\ m \times n$\\
  \lstinline!gradv(f)! & $\nabla f$ & evaluation function gradient    & $\mathrm{rank}(f(\overrightarrow{x}))+1$ & $p=1,\ m \times n$\\

  \lstinline!div(f)! & $\nabla \cdot \overrightarrow{f}$ & divergence of test function & $\mathrm{rank}( f(\overrightarrow{x}))-1$ & $1\times 1$\footnote{Divergence  of matrix value functions is not implemented, hence $p=1$ }\\
  \lstinline!divt(f)! & $\nabla \cdot \overrightarrow{f}$ & divergence of trial function & $\mathrm{rank}( f(\overrightarrow{x}))-1$ & $1\times 1$\\
  \lstinline!divv(f)! & $\nabla \cdot \overrightarrow{f}$ & evaluation of  function divergence  & $\mathrm{rank}( f(\overrightarrow{x}))-1$ & $1\times 1$\\

  \lstinline!curl(f)! & $\nabla \times \overrightarrow{f}$ & curl of test function & 1 & $n=m, n\times 1$\\
  \lstinline!curlt(f)! & $\nabla \times \overrightarrow{f}$ & curl of trial function & 1 & $m=n, n\times 1$\\
  \lstinline!curlv(f)! & $\nabla \times \overrightarrow{f}$ & evaluation of  function curl  & 1 & $m=n, n\times 1$\\

  \lstinline!hess(f)! & $\nabla^2 f$ & hessian of test function & 2 & $m=p=1, n\times n$\\\hline\\

  %%
  %% Two valued operators
  %%
  \lstinline!jump(f)! & $[f]=f_0\overrightarrow{N_0}+f_1\overrightarrow{N_1}$ & jump of test function & 1   & $m=1, n\times 1$\\
  \lstinline!jump(f)! & $[\overrightarrow{f}]=\overrightarrow{f_0}\cdot\overrightarrow{N_0}+\overrightarrow{f_1}\cdot\overrightarrow{N_1}$ & jump of test function & 0   & $m=2, 1\times 1$\\
  \lstinline!jumpt(f)! & $[f]=f_0\overrightarrow{N_0}+f_1\overrightarrow{N_1}$ & jump of trial function & 1   & $m=1, n\times 1$\\
  \lstinline!jumpt(f)! & $[\overrightarrow{f}]=\overrightarrow{f_0}\cdot\overrightarrow{N_0}+\overrightarrow{f_1}\cdot\overrightarrow{N_1}$ & jump of trial function & 0   & $m=2, 1\times 1$\\
  \lstinline!jumpv(f)! & $[f]=f_0\overrightarrow{N_0}+f_1\overrightarrow{N_1}$ & jump of  function evaluation & 1   & $m=1, n\times 1$\\
  \lstinline!jumpv(f)! & $[\overrightarrow{f}]=\overrightarrow{f_0}\cdot\overrightarrow{N_0}+\overrightarrow{f_1}\cdot\overrightarrow{N_1}$ & jump of  function evaluation & 0   & $m=2, 1\times 1$\\
  \lstinline!average(f)! & ${f}=\frac{1}{2}(f_0+f_1)$ & average of test function & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\
  \lstinline!averaget(f)! & ${f}=\frac{1}{2}(f_0+f_1)$ & average of trial function & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\
  \lstinline!averagev(f)! & ${f}=\frac{1}{2}(f_0+f_1)$ & average of  function evaluation & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\

  \lstinline!leftface(f)! & $f_0$ & left  test function & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\
  \lstinline!leftfacet(f)! & $f_0$ & left  trial function & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\
  \lstinline!leftfacev(f)! & $f_0$ & left   function evaluation & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\
  \lstinline!rightface(f)! & $f_1$ & right  test function & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\

  \lstinline!rightfacet(f)! & $f_1$ & right  trial function & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\
  \lstinline!rightfacev(f)! & $f_1$ & right   function evaluation & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m=n, n\times n$\\

  \lstinline!maxface(f)! & $\max(f_0,f_1)$ & maximum of right and left & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m\times p$\\
  && test   function&&\\
  \lstinline!maxfacet(f)! & $\max(f_0,f_1)$ & maximum of right and left & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m\times p$\\
  && trial   function&&\\
  \lstinline!maxfacev(f)! & $\max(f_0,f_1)$ & maximum of right and left & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m\times p$\\
  && function evaluation&&\\
  \lstinline!minface(f)! & $\min(f_0,f_1)$ & minimum of right and left & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m\times p$\\
  && test   function&&\\
  \lstinline!minfacet(f)! & $\min(f_0,f_1)$ & minimum of right and left & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m\times p$\\
  && trial   function&&\\
  \lstinline!minfacev(f)! & $\min(f_0,f_1)$ & minimum of right and left & $\mathrm{rank}( f(\overrightarrow{x}))$   & $m\times p$\\
  && function evaluation&&\\
  \hline\\
  %%
  %% Operations
  %%
  \lstinline!-! & $-g$ & element wise unary minus  & & \\
  \lstinline!!! & $!g$ & element wise logical not  & & \\\hline\\

  \lstinline!+! & $f+g$ & tensor sum  & & \\
  \lstinline!-! & $f-g$ & tensor substraction  & & \\
  \lstinline!*! & $f*g$ & tensor product  & & \\
  \lstinline!/! & $f/g$ & tensor division ($g$ scalar field)  & & \\\hline\\

  \lstinline!<! & $f < g$ & element wise less  & & \\
  \lstinline!<=! & $f \leq g$ & element wise less or equal  & & \\
  \lstinline!>! & $f > g$ & element wise greater  & & \\
  \lstinline!>=! & $f \geq g$ & element wise greater or equal  & & \\
  \lstinline!==! & $f = g$ & element wise  equal  & & \\
  \lstinline+!=+ & $f \neq g$ & element wise not equal  & & \\
  \lstinline!&&! & $f\ \text{and}\ g$ & element wise logical and  & & \\
  \lstinline!||! & $f\ \text{or}\ g$ & element wise logical or  & & \\\hline\\

\end{longtable}


\section{Operators}

\subsection{Integrals}
\label{keywords:integrals}

Thank to its finite element embedded language, \feel has its owned \lstinline!integrate()! function, which can be written for example :
\begin{lstlisting}
integrate( _range= elements(mesh), _expr= gradt(T)*trans(grad(v)) );
\end{lstlisting}
please notice that the order of the parameter is not important, these are \lstinline!boost! parameters, so you can enter them in the order you want. 
To make it clear, there are two required parameters and 2 optional and they of course can be entered in any order
provided you give the parameter name. If you don't provide the parameter name (that is to say \lstinline!_range=! or the others) they must be entered in the order they are described
below. \\

\noindent The required parameters are
\begin{itemize}
 \item \lstinline!_range!  = domain of integration
 \item \lstinline!_expr!  = integrand expression
\end{itemize}
The optional parameters are
\begin{itemize}
 \item \lstinline!_quad!  = quadrature to use instead of the default one, wich means \lstinline!_Q<integer>()! where the integer is the polynomal order to integrate exactely
 \item \lstinline!_geomap!  = type of geometric mapping to use, that is to say :
	\begin{itemize}
  	\item \lstinline!GEOMAP_HO!  =  high order approximation (same of the mesh)
  	\item \lstinline!GEOMAP_OPT!  = optimal approximation: high order on boundary elements, order 1 in the interior
  	\item \lstinline!GEOMAP_O1!  = order 1 approximation
	\end{itemize}
\end{itemize}


\subsection{Projections}
\label{keywords:projections}
It is also possible to make projections with the library, the interface is as follow :
\begin{lstlisting}
project( _range, _space, _expr, _geomap );
\end{lstlisting}
where
\begin{itemize}
 \item \lstinline!_space!  is the space in which lives the projected expression, it should be a nodal function space
  \item \lstinline!_expr!  the expression to project
  \item \lstinline!_range!  is the domain for the projection (optional, default: all elements from \lstinline!space->mesh()!) 
  \item \lstinline!_geomap!  is the type of geometric mapping approximation (optional, default = \lstinline!GEOMAP_OPT!)
  \item \lstinline!_accumulate!  (optional, default = false)
\end{itemize}

\subsection{Mean value}
Let $f$ a bounded function on domain $\Omega$. You can evaluate the mean value :
\begin{align*}
 \bar{f}&=\frac{1}{|\Omega|}\int_\Omega f\\
&=\frac{1}{\int\limits_\Omega 1}\int_\Omega f.
\end{align*}

\label{keywords:mean}
\noindent Interface :
\begin{lstlisting}
mean( _range, _expr, _quad, _geomap );
\end{lstlisting}

\noindent Required parameters :
\begin{itemize}
 \item \lstinline!_range! = domain of integration
 \item \lstinline!_expr! = mesurable function
\end{itemize}

\noindent Optional parameters :
\begin{itemize}
 \item \lstinline!_quad! = quadrature to use. Default = \lstinline!_Q<integer>()!
 \item \lstinline!_geomap! = type of geometric mapping. Default = \lstinline!GEOMAP_OPT!
\end{itemize}

\subsection{Meshes}
\label{keywords:meshes}

\feel enables full different ways to interact with the mesh on which you want to work. Mainly with the function \lstinline!integrate!, the various keywords we have established will make your program's code easier. The interoperability between \feel and \textsc{Gmsh} is huge and provides various access to any point, item, domain or almost anything you want in a mesh.
The access to different items of a mesh is possible thanks to the filters which enable the access of only a mesh's part. Theses helpfull keywords are coded in \lstinline!feel/feelmesh/filters.hpp!, we are here going to describe most of them. \\ \\ To access one particular part of a mesh, you can use :

\begin{itemize}
\item \lstinline!elements(mesh)!  corresponds to all the elements of a mesh
\item \lstinline!markedelements(mesh, id)!  corresponds to the precise element defined by the id. It can be any element (line, surface, domain, and so on).
\item \lstinline!faces(mesh)!  corresponds to all the faces of the mesh.
\item \lstinline!markedfaces(mesh)!  corresponds to all the faces of the mesh which are marked.
\item \lstinline!boundaryfaces(mesh)!  corresponds to all elements that own a topological dimension one below the mesh. For example, if you mesh is a 2D one, \lstinline!boundaryfaces(mesh)! will return all the lines (because of dimension $2-1=1$). These elements which have one dimension less, are corresponding to the boundary faces.
\item \lstinline!internalelements(mesh)!  corresponds to all the elements of the mesh which are stricly within the domain that is to say they do not share a face with the boundary.
\item \lstinline!boundaryelements(mesh)!  corresponds to all the elements of the mesh which share a face with the boundary of the mesh.
\item \lstinline!edges(mesh)!  corresponds to all the edges of the mesh.
\item \lstinline!boundaryedges(mesh)!  corresponds to all boundary edges of the mesh.
\end{itemize}
where id is the element's identifier : thanks to \textsc{Gmsh}, this identifier can be an integer or a string, it depends on the identifier your have or you gave in the mesh .geo file.

\section{Norms}
You can directly use the library to evaluate commun norms. Parameters are mostly similar to \lstinline!integrate()! function.

\subsection{L$^2$ Norm}
Let $f \in L^2(\Omega)$ you can evaluate the L2 norm :
$$\parallel f\parallel_{L^2(\Omega)}=\sqrt{\int_\Omega |f|^2}$$

\label{keywords:normL2}
\noindent Interface :
\begin{lstlisting}
normL2( _range, _expr, _quad, _geomap );
\end{lstlisting}
or squared norm :
\begin{lstlisting}
normL2Squared( _range, _expr, _quad, _geomap );
\end{lstlisting}

\noindent Required parameters :
\begin{itemize}
 \item \lstinline!_range! = domain of integration
 \item \lstinline!_expr! = mesurable function
\end{itemize}

\noindent Optional parameters :
\begin{itemize}
 \item \lstinline!_quad! = quadrature to use. Default = \lstinline!_Q<integer>()!
 \item \lstinline!_geomap! = type of geometric mapping. Default = \lstinline!GEOMAP_OPT!
\end{itemize}

\noindent Exemples :\\
With expression :
\begin{lstlisting}
double normL2_expr = normL2( _range=elements(mesh), \
			     _expr=sin(2*pi*Px())*cos(2*pi*Py()) );
\end{lstlisting}
With test or trial function \lstinline!u! :
\begin{lstlisting}
auto f = sin(2*pi*Px())*cos(2*pi*Py());
double errorL2 = normL2( _range=elements(mesh), \
			 _expr=(idv(u) - f) );
\end{lstlisting}


\subsection{H$^1$ Norm}
In the same idea, you can evaluate the H1 norm or semi norm, for any function $f \in H^1(\Omega)$ :
\begin{align*}
 \parallel f \parallel_{H^1(\Omega)}&=\sqrt{\int_\Omega |f|^2+|\nabla f|^2}\\
&=\sqrt{\int_\Omega |f|^2+\nabla f*\nabla f^T}\\
|f|_{H^1(\Omega)}&=\sqrt{\int_\Omega |\nabla f|^2}
\end{align*}

\label{keywords:normH1}
\noindent Interface :
\begin{lstlisting}
normH1( _range, _expr, _grad_expr, _quad, _geomap );
\end{lstlisting}
or semi norm :
\begin{lstlisting}
normSemiH1( _range, _grad_expr, _quad, _geomap );
\end{lstlisting}

\noindent Required parameters :
\begin{itemize}
 \item \lstinline!_range! = domain of integration
 \item \lstinline!_expr! = mesurable function
 \item \lstinline!_grad_expr! = gradient of function (Row vector !)
\end{itemize}

\noindent Optional parameters :
\begin{itemize}
 \item \lstinline!_quad! = quadrature to use. Default = \lstinline!_Q<integer>()!
 \item \lstinline!_geomap! = type of geometric mapping. Default = \lstinline!GEOMAP_OPT!
\end{itemize}

\noindent Exemples :\\
With expression :
\begin{lstlisting}
auto g = sin(2*pi*Px())*cos(2*pi*Py());
auto gradg = 2*pi*cos(2* pi*Px())*cos(2*pi*Py())*oneX() \
	     -2*pi*sin(2*pi*Px())*sin(2*pi*Py())*oneY();
// There gradg is a column vector !
// Use trans() to get a row vector
double normH1_g = normH1( _range=elements(mesh),\
			  _expr=g,\
			  _grad_expr=trans(gradg) );
\end{lstlisting}
With test or trial function \lstinline!u! :
\begin{lstlisting} 
double errorH1 = normH1( _range=elements(mesh),\
			 _expr=(u-g),\ 
			 _grad_expr=(gradv(u)-trans(gradg)) );
\end{lstlisting}


\subsection{Infinity Norm}
Let $f$ a bounded function on domain $\Omega$. You can evaluate the infinity norm :
$$\parallel f \parallel_\infty=\sup_\Omega(|f|)$$
\label{keywords:normLinf}
\noindent Interface :
\begin{lstlisting}
normLinf( _range, _expr, _pset, _geomap );
\end{lstlisting}

\noindent Required parameters :
\begin{itemize}
 \item \lstinline!_range! = domain of integration
 \item \lstinline!_expr! = mesurable function
 \item \lstinline!_pset! = set of points (e.g. quadrature points)
\end{itemize}

\noindent Optional parameters :
\begin{itemize}
 \item \lstinline!_geomap! = type of geometric mapping. Default = \lstinline!GEOMAP_OPT!
\end{itemize}

\noindent Exemples :
\begin{lstlisting}
auto uMax = normLinf( _range=elements(mesh),\
		     _expr=idv(u),\
		     _pset=_Q<5>() );
\end{lstlisting}







%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-parse-self: t
%%% x-symbol-8bits: nil
%%% TeX-auto-regexp-list: TeX-auto-full-regexp-list
%%% TeX-master: "feel-manual"
%%% ispell-local-dictionary: "american"
%%% End:

